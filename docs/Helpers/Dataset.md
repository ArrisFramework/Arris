Замена mapDataset, поддерживает расширенный синтаксис и коллбэки для обработки параметров

Практически, не метод фильтрации исходного массива, а метод генерации нового датасета на основе исходного

Структура правила:
KEY - имя правила
- source - из какого поля исходного массива брать данные? Если отсутствует - совпадает с ключом
- target - в какое поле целевого массива записать данные? Если отсутствует - совпадает с ключом
- default - значение поля в целевом массиве, если в исходном оно не найдено. Если не задано, то null (переопределимо 3 аргументом).
- processor - возвращаемый результат ИЛИ closure - функция, получающая два значения (исходное и исходный массив) и возвращающая значение
- type - приведение типа (int, str, string, bool, float ...)

Теперь о нюансах:
1) processor:
    а) - НЕ Closure - в результирующий массив передается его значение (которому может быть задан тип)
    б) - Closure - передается результат функции
2) чтобы просто скопировать ключ:значение из исходного массива, достаточно указать пустое правило для ключа ( например, `'mode' => []` )
3) результирующий массив содержит ТЕ И ТОЛЬКО ТЕ ключи, которые указаны в списке ПРАВИЛ.
4) если в исходном массиве нет ключа XXX, то в результирующем будет XXX => null (по умолчанию)

Прежнее поведение: если в processor строка, то она интерпретируется как допустимая функция - удалено.
Это работало только если функция принимала два аргумента (строка и массив) и давало малопредсказуемые результаты
